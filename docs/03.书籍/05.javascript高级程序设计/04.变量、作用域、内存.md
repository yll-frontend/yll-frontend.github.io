---
title: 变量、作用域、内存
date: 2021-07-15 06:57:05
permalink: /pages/91cece/
categories:
  - 书籍
  - javascript高级程序设计
tags:
  - 
---
# 变量、作用域、内存

## 确定类型

`typeof`操作符适合用来判断一个变量是否为原始类型
`instanceOf`操作符用来确定引用值的类型
:::tip
`typeof`在检测函数时也会返回`function`
:::

## 执行上下文与作用域

变量或函数的上下文决定了他们可以访问到那些数据，以及他们的行为。每个**上下文**都有一个关联的**变量对象**，这个上下文中定义的所有变量以及函数都存于这个对象上。

+ 全局上下文是最外层的上下文，在浏览器中就是我们所说的window对象，但是`let`和`const`的顶级声明不会定义在全局上下文中。
:::tip
全局上下文只有在关闭网页或退出浏览器才会被销毁
:::

+ 上下文在执行的时候会创建一个变量对象的**作用域链**，这个作用域链决定了各个上下文的代码在访问变量和函数时的顺序。如果上下文是一个函数，则其**活动对象**用作变量对象，活动对象最初只有一个定义变量:`arguments`.(全局上下文中没有这个变量)
:::tip
函数参数被默认为是当前上下文中的变量，因此也跟上下文中的其他变量以遵循相同的访问规则
:::

## 作用域链增强

执行上下文主要由去全局上下文和函数上下文两种，担忧其他方式来增强作用域链。某些语句会导致在作用于连的最前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常会在两种情况下会出现这个现象：

+ >try/catch语句的catch块
+ >with语句

## 垃圾回收

### 标记清理

JavaScript最常用的垃圾回收策略是**引用计数**。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于山下文中的标记，当变量离开上下文也会被加上离开上下文的标记。
给变量添加标记的方法有很多种。比如，当变量进入上下文时反转某一位;或者可以维护“在上下文”和“不在上下文”两个变量列表，可以把变量从一个列表转移到另一个列表等。
垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后将所有在上下文中的变量以及上下文中的变量引用的变量的标记清除。对吼做一次内存清理，销毁所有带有标记的变量，并且回收他们的内存。

### 引用计数

思路是对每个值记录它被引用的次数，当引用次数为0时，垃圾回收程序下次运行会释放这个变量的内存。但是存在一个**循环引用**的问题:

```js
function problem() {
  let objectA = new Object();
  let objectB = new Object();
           
  objectA.someOtherObject = objectB;
  objectB.anotherObject = objectA;
}
```

在这个例子中，objectA和objectB通过各自的属性相互引用，意味着他们的引用数都是2，在引用计数的策略下，他们在函数结束后还会存在。
:::danger
在IE中，`window.CollectionGarbage()`会立即粗发垃圾回收，在Opera以及更高版本中，`window.opera.collect()`也会触发垃圾回收程序，但是并不推荐主动触发垃圾回收
:::

## 小结

+ 原始值大小固定，保存在栈上
+ 引用值是对象，保存在堆内存上
+ 从一个变量到另一个变量复制值，只会复制指针，因此结果是两个变量指向同一个对象
+ 执行上下文分为全局上下文、函数上下文以及块级上下文
+ 代码执行流没进入一个新上下文，都会创建一个作用链，用于搜索变量和函数
+ 函数和块的局部上下文不仅可以访问自己的作用域内的变量，也可以访问任何包含上下文以及全局上下文的变量
