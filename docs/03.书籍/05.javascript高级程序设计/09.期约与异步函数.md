---
title: 期约与异步函数
date: 2021-09-22 06:55:14
permalink: /pages/c9a70e/
categories:
  - 书籍
  - javascript高级程序设计
tags:
  - 
---
# Promise与异步函数

## Promise

### 非重入特性

当`Promise`进入落定状态时，与该状态相关的处理层序仅仅会排期，而非立即执行。跟在处理程序之后的同步代码一定会在出路程序之前执行。即使`Promise`一开始就是与附加处理程序相关联的状态，执行顺序也是这样的。这种特性称为非重入特性。  

### `Promise.resolve()`

+ 期约并非一开始就必须处于待定状态，然后通过执行器函数函数才能转换为落地状态，通过调用`Promise.resolve()`静态方法，可以实例化一个期约。

```js
let p1 = new Promise((resolve, reject) => resolve());
let p2 = Promise.resolve();
```

+ 使用这个静态方法可以把任何值转换为一个期约。

```js
setTimeout(console.log, 0, Promise.resolve());
// Promise <resolved>: undefined

setTimeout(console.log, 0, Promise.resolve(3));
// Promise <resolved>: 3

// 其余的参数会忽略
setTimeout(console.log, 0, Promise.resolve(4, 5, 6));
// Promise <resolved>: 4

```

+ `Promise.resolve()`是一个幂等方法。

### Promise.reject()

与`Promise.resolve()`类似，`Promose.reject()`会实例化一个拒绝的期约并抛出一个异步的错误（这个错误不能通过`try/catch`捕获，只能通过错误处理程序捕获）。下面两个期约实例实际上是一样的：

```js
let p1 = new Promise((resolve, reject) => reject());
let p2 = Promise.reject();
```

`Promise.reject`如果传入一个期约对象，这个期约会成为他拒绝的理由。

```js
let p = Promise.reject(3);
setTimeout(console.log, 0, p);  // Promise <rejected>: 3

p.then(null, (e) => setTimeout(console.log, 0, e));  // 3
```

### 同步/异步执行的二元性

```js
try {
  throw new Error('foo');
} catch(e) {
  console.log(e);  // Error: foo
}

try {
  Promise.reject(new Error('bar'));
} catch(e) {
  console.log(e);
}
// Uncaught (in promise) Error: bar
```

第一个`try/catch`捕获到了错误，第二个没有。虽然代码确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误。这里没有捕获到错误的原因是，没有通过`异步模式`捕获错误。从这里可以看出期约的真正的异步特性，`他们是同步对象（在同步模式中执行使用，但也是异步执行的媒介）`

### 期约扩展

+ 期约取消

```js
class CancelToken {
  constructor(cancelFn) {
    this.promise = new Promise((resolve, reject) => {
      cancelFn(resolve);
    });
  }
}
```

使用：

```html
<button id="start">Start</button>
<button id="cancel">Cancel</button>

<script>
class CancelToken {
  constructor(cancelFn) {
    this.promise = new Promise((resolve, reject) => {
      cancelFn(() => {
        setTimeout(console.log, 0, "delay cancelled");
        resolve();
      });
    });
  }
}

const startButton = document.querySelector('#start');
const cancelButton = document.querySelector('#cancel');

function cancellableDelayedResolve(delay) {
  setTimeout(console.log, 0, "set delay");
  
  return new Promise((resolve, reject) => {
    const id = setTimeout((() => {
      setTimeout(console.log, 0, "delayed resolve");
      resolve();
    }), delay);
    
    const cancelToken = new CancelToken((cancelCallback) => 
        cancelButton.addEventListener("click", cancelCallback));
    
    cancelToken.promise.then(() => clearTimeout(id));
  });
}

startButton.addEventListener("click", () => cancellableDelayedResolve(1000)); 
</script>
```

+ 进度追踪

```js
class TrackablePromise extends Promise {
  constructor(executor) {
    const notifyHandlers = [];
    
  super((resolve, reject) => {
    return executor(resolve, reject, (status) => {
        notifyHandlers.map((handler) => handler(status));
      }) ;
    });
    
    this.notifyHandlers = notifyHandlers;    
  }
  
  notify(notifyHandler) {
    this.notifyHandlers.push(notifyHandler);
    return this;
  }
}
```

使用：

```js
let p = new TrackablePromise((resolve, reject, notify) => {
  function countdown(x) {
    if (x > 0) {
       notify(`${20 * x}% remaining`);
       setTimeout(() => countdown(x - 1), 1000);
    } else {
      resolve();
    }
  }

  countdown(5);
});

...

let p = new TrackablePromise((resolve, reject, notify) => {
  function countdown(x) {
    if (x > 0) {
       notify(`${20 * x}% remaining`);
       setTimeout(() => countdown(x - 1), 1000);
    } else {
      resolve();
    }
  }

  countdown(5);
});

p.notify((x) => setTimeout(console.log, 0, 'progress:', x));

p.then(() => setTimeout(console.log, 0, 'completed'));

// (after 1s) 80% remaining
// (after 2s) 60% remaining
// (after 3s) 40% remaining
// (after 4s) 20% remaining
// (after 5s) completed 

```

:::tip
ES6不支持取消期约和进度通知，一个主要原因是这样会导致期约连锁和期约合成复杂化。比如在一个期约连锁中，如果某个被其他期约依赖的期约被取消了，那么接下来应该发生什么完全说不清楚。
:::

## 异步函数

**异步函数**也称为`async/await`，ES8规范新增的，让同步方式写的代码以异步执行，下面是一个简单的例子：

```js
function handler(x) { console.log(x); }

let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3));

p.then(handler);  // 3
```

### 异步函数

#### async

`async`关键字用于声明异步函数，这个关键字可以用在函数声明、函数表达式、箭头函数以及方法上：

```js
async function foo() {}

let bar = async function() {};

let baz = async () => {};

class Qux {
  async qux() {}
}
```

使用`async`关键字可以让函数具有异步特征，但总体上仍然是同步求值的，下面的例子展示了这一点：

```js
async function foo() {
  console.log(1);
}

foo();
console.log(2);

// 1
// 2
```

不过如果函数使用`return`关键字返回了值（没有`return`会返回`undefined`）,这个值会被`Promise.resolve()`包装成一个期约对象。异步函数使用返回期约对象。

```js
async function foo() {
  console.log(1);
  return 3;
}

// 给返回的期约添加一个处理程序
foo().then(console.log);

console.log(2);

// 1
// 2
// 3

```

直接返回一个期约也是一样的

```js
async function foo() {
  console.log(1);
  return Promise.resolve(3);
}

// Attach a resolved handler to the returned promise
foo().then(console.log);

console.log(2);

// 1
// 2
// 3

```

在异步函数中抛出错误会返回拒绝的期约：

```js
async function foo() {
  console.log(1);
  throw 3;
}

foo().catch(console.log);
console.log(2);

// 1
// 2
// 3
```

**但是，拒绝的期约不会被异步函数捕获：**

```js{11}
async function foo() {
  console.log(1);
  Promise.reject(3);
}

foo().catch(console.log);
console.log(2);

// 1
// 2
// Uncaught (in promise) 3
```

#### await

使用`await`关键字可以暂停异步代码的执行，等待期约解决：

```js
let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3));

p.then((x) => console.log(x));  // 3

```

上面的例子可以写成：

```js
async function foo() {
  let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3));
  console.log(await p);
}

foo();
// 3
```

注意，`await`关键字可以暂停异步代码函数后面的代码，让出JavaScript运行时的执行线程。这个行为与生成器函数中的`yield`关键字是一样的。
`await`关键字可以单独使用，可以在表达式中使用：

```js
// 异步打印"foo"
async function foo() {
  console.log(await Promise.resolve('foo'));
}
foo();
// foo


// 异步打印 "bar"
async function bar() {
  return await Promise.resolve('bar');
}
bar().then(console.log);
// bar

//异步打印在1000ms后 "baz"
async function baz() {
  await new Promise((resolve, reject) => setTimeout(resolve, 1000));
  console.log('baz');
}
baz();
// baz <1000ms后>
```

`await`关键字期待（但并不要求）一个实现`thenable`接口的对象，常规的值也可以。如果实现`thenable`接口的对象，会使用`await`来解包，如果不是，这个值就会被当做已经解决的期约：

```js
// 等待原始值
async function foo() {
  console.log(await 'foo');
}
foo();
// foo

// 等待一个没有实现thenable接口的对象
async function bar() {
  console.log(await ['bar']);
}
bar();
// ['bar']

// 等待一个实现thenable接口的对象
async function baz() {
  const thenable = {
    then(callback) { callback('baz'); }
  };
  console.log(await thenable);
}
baz();
// baz

// 等待一个期约
async function qux() {
  console.log(await Promise.resolve('qux'));
}
qux();
// qux
```
