---
title: 期约与异步函数
date: 2021-09-22 06:55:14
permalink: /pages/c9a70e/
categories:
  - 书籍
  - javascript高级程序设计
tags:
  - 
---
# Promise与异步函数

## Promise

### 非重入特性

当`Promise`进入落定状态时，与该状态相关的处理层序仅仅会排期，而非立即执行。跟在处理程序之后的同步代码一定会在出路程序之前执行。即使`Promise`一开始就是与附加处理程序相关联的状态，执行顺序也是这样的。这种特性称为非重入特性。  

### `Promise.resolve()`

+ 期约并非一开始就必须处于待定状态，然后通过执行器函数函数才能转换为落地状态，通过调用`Promise.resolve()`静态方法，可以实例化一个期约。

```js
let p1 = new Promise((resolve, reject) => resolve());
let p2 = Promise.resolve();
```

+ 使用这个静态方法可以把任何值转换为一个期约。

```js
setTimeout(console.log, 0, Promise.resolve());
// Promise <resolved>: undefined

setTimeout(console.log, 0, Promise.resolve(3));
// Promise <resolved>: 3

// 其余的参数会忽略
setTimeout(console.log, 0, Promise.resolve(4, 5, 6));
// Promise <resolved>: 4

```

+ `Promise.resolve()`是一个幂等方法。

### Promise.reject()

与`Promise.resolve()`类似，`Promose.reject()`会实例化一个拒绝的期约并抛出一个异步的错误（这个错误不能通过`try/catch`捕获，只能通过错误处理程序捕获）。下面两个期约实例实际上是一样的：

```js
let p1 = new Promise((resolve, reject) => reject());
let p2 = Promise.reject();
```

`Promise.reject`如果传入一个期约对象，这个期约会成为他拒绝的理由。

```js
let p = Promise.reject(3);
setTimeout(console.log, 0, p);  // Promise <rejected>: 3

p.then(null, (e) => setTimeout(console.log, 0, e));  // 3
```

### 同步/异步执行的二元性

```js
try {
  throw new Error('foo');
} catch(e) {
  console.log(e);  // Error: foo
}

try {
  Promise.reject(new Error('bar'));
} catch(e) {
  console.log(e);
}
// Uncaught (in promise) Error: bar
```

第一个`try/catch`捕获到了错误，第二个没有。虽然代码确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误。这里没有捕获到错误的原因是，没有通过`异步模式`捕获错误。从这里可以看出期约的真正的异步特性，`他们是同步对象（在同步模式中执行使用，但也是异步执行的媒介）`

### 期约扩展

+ 期约取消

```js
class CancelToken {
  constructor(cancelFn) {
    this.promise = new Promise((resolve, reject) => {
      cancelFn(resolve);
    });
  }
}
```

使用：

```html
<button id="start">Start</button>
<button id="cancel">Cancel</button>

<script>
class CancelToken {
  constructor(cancelFn) {
    this.promise = new Promise((resolve, reject) => {
      cancelFn(() => {
        setTimeout(console.log, 0, "delay cancelled");
        resolve();
      });
    });
  }
}

const startButton = document.querySelector('#start');
const cancelButton = document.querySelector('#cancel');

function cancellableDelayedResolve(delay) {
  setTimeout(console.log, 0, "set delay");
  
  return new Promise((resolve, reject) => {
    const id = setTimeout((() => {
      setTimeout(console.log, 0, "delayed resolve");
      resolve();
    }), delay);
    
    const cancelToken = new CancelToken((cancelCallback) => 
        cancelButton.addEventListener("click", cancelCallback));
    
    cancelToken.promise.then(() => clearTimeout(id));
  });
}

startButton.addEventListener("click", () => cancellableDelayedResolve(1000)); 
</script>
```

+ 进度追踪

```js
class TrackablePromise extends Promise {
  constructor(executor) {
    const notifyHandlers = [];
    
  super((resolve, reject) => {
    return executor(resolve, reject, (status) => {
        notifyHandlers.map((handler) => handler(status));
      }) ;
    });
    
    this.notifyHandlers = notifyHandlers;    
  }
  
  notify(notifyHandler) {
    this.notifyHandlers.push(notifyHandler);
    return this;
  }
}
```

使用：

```js
let p = new TrackablePromise((resolve, reject, notify) => {
  function countdown(x) {
    if (x > 0) {
       notify(`${20 * x}% remaining`);
       setTimeout(() => countdown(x - 1), 1000);
    } else {
      resolve();
    }
  }

  countdown(5);
});

...

let p = new TrackablePromise((resolve, reject, notify) => {
  function countdown(x) {
    if (x > 0) {
       notify(`${20 * x}% remaining`);
       setTimeout(() => countdown(x - 1), 1000);
    } else {
      resolve();
    }
  }

  countdown(5);
});

p.notify((x) => setTimeout(console.log, 0, 'progress:', x));

p.then(() => setTimeout(console.log, 0, 'completed'));

// (after 1s) 80% remaining
// (after 2s) 60% remaining
// (after 3s) 40% remaining
// (after 4s) 20% remaining
// (after 5s) completed 

```

:::tip
ES6不支持取消期约和进度通知，一个主要原因是这样会导致期约连锁和期约合成复杂化。比如在一个期约连锁中，如果某个被其他期约依赖的期约被取消了，那么接下来应该发生什么完全说不清楚。
:::
